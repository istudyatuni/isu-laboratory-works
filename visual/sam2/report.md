---
title: Самостоятельная работа №2
subtitle: Визуализация и мультимедиа
---
\clearpage

# Лабораторная работа № 3. Работа с текстом

Работа с текстом в SVG похожа на таковую в HTML - возможно задание свойств для шрифтов, межстрочного и межбуквенного расстояния, расстояния между отдельными словами, наклон, курсив, под/надчеркивание, и так далее, а так же и то, чего с помощью обычного css+html добиться довольно сложно. Для демонстрации изученного материала я написал не очень большой SVG-документ, но в нем есть присутствуют почти все изученные элементы.

0. Чтобы нарисовать текст на SVG полотне, необходимо создать элемент `text` c атрибутами `x` и `y` для задания положения:

```xml
<text x="10" y="20">Text</text>
```

1. Привязка текста к кривой, заданной элементом `path`.

Для начала необходимо задать саму кривую (так же можно поместить в `<defs>`, чтобы она не отображалась, а текст был все равно по ее контуру), и задать для нее `id`:

```xml
<path id="path1" d="M20,20 q 30,-30 50,20 t30,-30"/>
```

Далее создаем элемент `text` и внутри него элемент `textPath` для привязки к кривой:

```xml
<text>
	<textPath href="#path1">Text</textPath>
</text>
```

2. Задание отличающегося отображения для отдельных частей внутри тега `text` с помощью элемента `tspan`, или перенос строк (каждая строка внутри нового `tspan`)

Для элемента `text` задаем дочерние элементы:

```xml
<text font-size="14" text-anchor="middle" fill="blue">
	<tspan dy="-7 7" style="fill:cyan" rotate="50">test</tspan>
	<tspan style="fill:red" dx="0 2" dominant-baseline="hanging">more</tspan>
</text>
```

Для них кроме задания своих стилей можно указать оступы каждой отдельной буквы (`dx` по горизонтали, `dy` по вертикали), повороты, расположение относительно основной линии (под, над (по умолчанию)).

3. Направление текста

Задается свойством `direction`, значение по умолчанию - `ltr` (left to right), также возможно `rtl` (right to left). Чтобы работало, необходимо также установить свойство `unicode-bidi` в значение `bidi-override`:

```xml
<tspan style="direction: rtl; unicode-bidi: bidi-override">text</tspan>
```

4. Стили шрифтов из CSS 3

`font-size`, `font-family`, `text-decoration`, `word-spacing`, и так далее:

```xml
<text style="text-decoration: overline; word-spacing: 2.5">text</text>
```

Получившееся изображение выглядит следующим образом:

![](screenshot-lab3.png)

Код: [*Приложение 1*](#приложение-1)

# Лабораторная работа № 4. Рисование

В SVG также кроме прочего доступен довольно большой набор инструментов для рисования - различные заливки, оформления контуров, и так далее.

## Заливки

1. Обычная заливка.

Кроме обычной заливки `fill` для нее можно задавать прозрачность `fill-opacity` и указать оставлять пустые области: `fill-rule`, например:

```xml
<text x="270" y="50" style="fill:blue; fill-opacity: 0.3">Just text</text>
```

сделает заливку прозрачной на 70%, а применение правила `fill-rule="evenodd"` (у которого значение по умолчанию `nonzero`), например, к элементу в форме звезды, отменит заливку центральной части:

```xml
<polygon style="fill:cyan; fill-rule: evenodd" points="50,0 100,63 28,97 10,20 90,20 72,97 0,63"/>
```

2. Линейная градиентная заливка.

Эта заливка предназначается для получения плавного цветового перехода, и задается элементом `linearGradient`, который определяется в области `defs`, а затем применяем как заливку:

```xml
<defs>
	<linearGradient id="grad_lin1" x1="0%" y1="0%" x2="100%" y2="100%">
	<stop offset="0%" stop-color="yellow"/>
	<stop offset="100%" stop-color="red"/>
	</linearGradient>
</defs>
<rect x="100" width="90" height="50" style="fill:url(#grad_lin1)" />
```

Для задания такой заливки необходимо задать элементы `stop` с атрибутами `offset` и `stop-color`, отвечающими за границу области каждого из цветов, и сам цвет соответственно. В качестве атрибутов самого элемента `linearGradient` можно задать значения, которые отвечают за направление изменения цветов.

В примере выше получится прямоугольник, с переходом от желтого цвета из левого верхнего угла до красного цвета в правый нижний угол.

Также задаем прозрачность градиента через атрибут `stop-opacity`:

```xml
<stop offset="100%" stop-color="cyan" stop-opacity="10%"></stop>
```

3. Радиальная градиентная заливка.

Эта заливка похожа на линейную, только изменение цветов идеть кругами, как круги на воде. А ее задание полностью совпадает с линейной, другой только элемент: `radialGradient`:

```xml
<defs>
	<radialGradient id="grad_rad1">
		<stop offset="0%" stop-color="#FF1C9D"></stop>
		<stop offset="100%" stop-color="cyan" stop-opacity="10%"></stop>
	</radialGradient>
</defs>
```

Также задаем область распространения прямо в тегах элемента `radialGradient`:

```xml
<defs>
	<radialGradient id="grad_rad2" cx="50%" cy="50%" r="40%">
		<stop offset="0%" stop-color="darkblue"></stop>
		<stop offset="80%" stop-color="pink" stop-opacity="80%"></stop>
	</radialGradient>
</defs>
```

## Паттерны

Для создания мозаичной фигуры, в которой используется повторяющийся фрагмент, используем элемент `pattern`, который тоже применяем как заливку:

```xml
<pattern id="pattern1" x="0" y="0" width="22" height="22" patternUnits="userSpaceOnUse" >
<ellipse cx="11" cy="21" rx="10" ry="20" fill="url(#grad_rad2)" stroke="black"/>
</pattern>
<rect x="10" y="140" width="146" height="146" fill="url(#pattern1)" />
```

`patternUnits` определяет координатную систему для атрибутов `x` `y` `width` `height`, если `userSpaceOnUse`, то эти атрибуты определяются в системе координат той фигуры, в которой будет применен шаблон.

Из фрагмента выше получится узор, немного похожий на рыбью чешую

## Контуры

Простейшие контуры уже создавались раньше - атрибуты `stroke` и `stroke-width`. Также возможно задавать выбрать вид концов прямых (`stroke-linecap`, значения: `butt` - обычный (по умолчанию), `round` - скругленный, или `square` - с выступом), тип линии на изгибе (`stroke-linejoin`, значения: `mitre` - обычный (по умолчанию), `round` - сглаженный, `bevel` - рубленный).

```xml
<polygon style="stroke:cyan; stroke-linecap: round; stroke-linejoin: round; stroke-dasharray: 13,5,7,3; stroke-opacity: 0.5" points="50,0 100,63 28,97 10,20 90,20 72,97 0,63"/>
```

Сниппет кода выше задает звезду из предыдущего раздела, только отличается способ оформления линий контура.

## Маркеры

Этот элемент предназначен для создания стрелок, для этого может использоваться графический элемент или группу элементов. Определение помещается в секцию `defs`, а потом используется в аргументе `marker-end`:

```xml
<defs>
	<marker id="marker1" markerWidth="25" markerHeight="25" orient="250" refX="5">
		<polygon style="fill:none; stroke: green;" stroke-width="1" points="0,0 5,10 10,0" />
	</marker>
</defs>
<line x1="170" y1="70" x2="240" y2="50" stroke="red" stroke-width="2" marker-end="url(#marker1)"/>
```

`refX` и `refY` задают координаты верхней левой точки фигуры (по умолчанию 0), `orient` - поворот фигуры.

## Symbol

Похоже на маркер, но используется не только для стрелок, но в принципе для группировки и последующего переиспользования группы элементов.

```xml
<defs>
	<symbol id="symbol1" viewBox="0 0 100 100" preserveAspectRatio="none">
		<path d="M0,0 l 50,50 M 50,0 l -50,50" />
	</symbol>
</defs>
<use x="38" y="40" href="#symbol1" width="50" height="50" style="fill: black; stroke: black;" stroke-width="5" />
<use x="135" y="15" href="#symbol1" width="50" height="50" style="fill: black; stroke: black;" stroke-width="10" />
```

Атрибуты: `viewBox` - размер системы координат для элементов в элементе, `preserveAspectRatio="none"` - если установлено так, то размеры элемента можно изменять без соблюдения пропорций.

## Элемент clipPath

Этот элемент предназначен для отсекания заданной областью части изображения. Он также заключается в `defs`, и потом используется в изображении в атрибуте `clip-path`:

```xml
<defs>
	<clipPath id="clippath1">
		<circle cx="210" cy="150" r="30" />
		<circle cx="250" cy="150" r="30" />
	</clipPath>
</defs>
<image x="180" y="100" width="100" height="100" href="im.png" clip-path="url(#clippath1)" />
```

Из примера выше получится картинка, ограниченная двумя кругами в форме бинокля.

*Примечание*. Если подключать svg-изображение в html с помощью тега `<img>`, то при использовании в самом svg тега `image` внутренняя картинка не будет отображаться. Для правильного отображения надо подключать так:

```html
<object type="image/svg+xml" data="image.svg"></object>
```

## Элемент mask

Аналогичен элементу `clipPath`, но оформление фигуры внутри элемента не игнорируется.

```xml
<defs>
	<mask id="mask1">
		<circle cx="210" cy="230" r="30" style="fill:url(#grad_rad2)" />
		<circle cx="250" cy="230" r="30" style="fill:url(#grad_rad1)" />
	</mask>
</defs>
<image x="180" y="190" width="100" height="100" href="im.png" mask="url(#mask1)" />
```

Для примера здесь используется заливка радиальным градиентом, остальное выглядит как и в предыдущем пункте.

Оба эти элемента - `mask` и `clipPath`, могут содержать в себе любые фигуры svg, включая текст, `path`, `polygon`, и так далее.

В итоге получилась такая картинка:

![](screenshot-lab4.png)

Код: [*Приложение 2*](#приложение-2)

# Вывод

Можно не просто рисовать квадратики и кружочки, но и разукрашивать их!
